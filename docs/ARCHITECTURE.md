# 📐 ARCHITECTURE

We have Spaghetti ARCHITECTURE inspired by Flying Spaghetti Monster

Tools and libraries:
* For start:
  * [ ] [Summoner](https://kowainik.github.io/projects/summoner) for scaffolding fully configured batteries-included production-level Haskell projects
  * [ ] [cake-slayer](https://github.com/kowainik/cake-slayer) - Architecture of Haskell backend applications
  * [ ] [three-layer](https://github.com/Holmusk/three-layer) - Architecture of Haskell backend applications
  * [ ] [cabal-fmt](https://github.com/phadej/cabal-fmt) for format .cabal files
* For static code analysis:
  * [ ] [hlint](https://github.com/ndmitchell/hlint) for source code suggestions
    * [ ] [hlint-test](https://github.com/Siprj/hlint-test#readme) for run hlint in test suite
  * [ ] [weeder](https://github.com/ocharles/weeder) for detect dead code
  * [ ] [stan](https://kowainik.github.io/projects/stan) for STatic ANalysis
* For dynamic code analysis:
  * [ ] [hspec](https://hspec.github.io/) for unit and integration tests
    * [ ] [hspec-golden](https://github.com/stackbuilders/hspec-golden#readme) for golden tests
    * [ ] [hspec-slow](https://github.com/SupercedeTech/hspec-slow) for find slow test cases
  * [ ] [gauge](https://github.com/vincenthz/hs-gauge) for performance measurement and analysis
  * [ ] [weigh](https://github.com/fpco/weigh#readme) for measure allocations of a Haskell functions/values
* For configuration:
  * [ ] [optparse-applicative](https://github.com/pcapriotti/optparse-applicative) for parse options
  * [ ] [tomland](https://kowainik.github.io/posts/2019-01-14-tomland) for configuration from file
  * [ ] [dhall-haskell](https://github.com/dhall-lang/dhall-haskell) for configuration from file
* For patching List:
  * [ ] [ilist](https://hackage.haskell.org/package/ilist) for doing index-related things
  * [ ] [list-singleton](https://hackage.haskell.org/package/list-singleton) for easily and clearly create lists with only one element in them
  * [ ] [slist](https://kowainik.github.io/projects/slist) for sized list
  * [ ] [split](https://hackage.haskell.org/package/split) for splitting lists 
* For production code:
  * [ ] [mtl](https://github.com/haskell/mtl) for IoC
  * [ ] [RIO](https://github.com/commercialhaskell/rio#readme) as standard library
  * [ ] [mono-traversable](https://github.com/snoyberg/mono-traversable#readme) as container standard library
  * [ ] [data-default](https://hackage.haskell.org/package/data-default) for default values
  * [ ] [validation-selective](https://github.com/kowainik/validation-selective) is lighweight pure data validation based on Applicative and Selective functors
  * [ ] [filepath](https://github.com/haskell/filepath#readme) for manipulating FilePaths in a cross platform way. 
  * [ ] [pretty-simple](https://github.com/cdepillabout/pretty-simple) for data types with a 'Show' instance

## 🌈 ❤️ 💛 💚 💙 🤍 🖤 🦄
